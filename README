gnucap-adms package
Copyright: 2012-13 Felix Salfelder <felix@salfelder.org>
License: GPL3+

This package helps compiling verilog-a models to gnucap devices.

synopsis:
    gnucap-adms [options] file.va

    generates c++ code distributed over file.cc file.h file_top.hxx ...
    containing a gnucap device

-v  verbose output
-c  compile shared object (file.so)
-t  compile with -DDO_TRACE
-g  compile with -g
-o  compile optimized and NDEBUG
-d  debug admsXml

installation prerequisites:
 - patched admsXml 2.3.0, available at
   git://tool.em.cs.uni-frankfurt.de/git/adms
 - gnucap-uf or gnucap 0.36+dev, available at
   git://tool.em.cs.uni-frankfurt.de/git/gnucap
   or (debian package)
   git://tool.em.cs.uni-frankfurt.de/git/gnucap_deb

configuration:
 --enable-local install plugins to $HOME/.gnucap/lib (in case you have no write
                access to gnucap_libdir)
                you then will have to invoke gnucap like
                LD_LIBRARY_PATH=$HOME/.gnucap/lib
                in order to load the plugins

features:
 - simple user interface
 - works with gnucap-uf and almost with gnucap
 - sparse matrix allocation
 - initial conditions (experimental)
 - disciplines from discipline.h (experimental)
 - subdevices (incomplete, but works)
 - under active development

bugs:
 - should use Makefile for translate/compile rules
 - ... lots. lets fix the serious ones first

remarks:
 - some details don't work with gnucap 0.36, cf. examples
 - indentation in gnucap.xml (two spaces) has been taken over from "adms-mot",
   the generated code should be approximately BSD KNF style.

==== note on split.py ====
The script gnucap.xml will be modified, before can be used by admsXml:

split.py: split gnucap.xml in many files, for each scope in gnucap.xml respectively
Reason: many script-files allow you to implement something like derivation, for example:
	admsXml -e sript1.xml -e script2.xml -e script3.xml

	script1:
		template a calls b
		template b
	script2:
		calls a (-> calls script1::b)
	script3:
		template b
		calls a (-> calls script3::b)

If you try to impement this example with scopes, the script2-"a"-call will use script3::b (looks like a bug).
