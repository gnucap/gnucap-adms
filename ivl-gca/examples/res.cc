
/* AUTOMATICALLY GENERATED BY ADMS-XML
 * brought to you by Andreas Froese,
 *                   Felix Salfelder
 * do not edit
 */
#include <limits>
#include <map>
#include <boost/assign.hpp>
#include <boost/algorithm/string.hpp>
#include <stdio.h>
#include <math.h>

#ifndef ADD_VERSION
# define ADD_VERSION
#endif
#include <globals.h>

#include <u_xprobe.h>
#include <e_paramlist.h>
#include <e_storag.h>
#include <e_model.h>
#include <e_compon.h>
#include <e_adms.h>
#include <u_parameter.h>
#include <e_admsrc.h>
#include <m_part.h>

namespace {
#include "res.h"

using namespace std;
const double NA(NOT_INPUT);


  //analog function stuff

static DEV_RES p_dev_res;
// static DISPATCHER<CARD>::INSTALL d_res_0(&device_dispatcher, "dev_res", &p_dev_res);

static MODEL_RES p_res(&p_dev_res);
static DISPATCHER<MODEL_CARD>::INSTALL d_res_1(&model_dispatcher, "res", &p_res);

static COMMON_RES Default_COMMON_RES(CC_STATIC);

// ********************************* MODEL_RES ********************************* //
MODEL_RES::MODEL_RES(const DEV_RES* p) :
    MODEL_CARD(p),
	 v_R(
		100

),
    _key("dev_res"),
    _level()
{
	// @(initial_model) block
	MODEL_RES *m = this; USE(m);
}
// -------------------------------------------------------------------------- //
MODEL_RES::MODEL_RES(const MODEL_RES& p) :
    MODEL_CARD(p),
    v_R(p.v_R),
    _key(p._key),
    _level(p._level)
{
}
// -------------------------------------------------------------------------- //
MODEL_RES::~MODEL_RES()
{
}
// -------------------------------------------------------------------------- //
int MODEL_RES::param_count() const
{
	return(1);
}
// -------------------------------------------------------------------------- //
bool MODEL_RES::param_is_printable(int) const
{
	return(true);
}
// -------------------------------------------------------------------------- //
std::string MODEL_RES::param_name(int i)const
{
	switch(i)
	{
		case 0: return("R");
		default: return("");
	}
	return("");
}
// -------------------------------------------------------------------------- //
std::string MODEL_RES::param_name(int i, int j)const
{
	if( j == 0 ) return(param_name(i));
	return("");
}
// -------------------------------------------------------------------------- //
std::string MODEL_RES::param_value(int i) const
{
	switch(i)
	{
		case 0: return(v_R.string());
		default: return("");
	}
	return("");
}
// -------------------------------------------------------------------------- //
void MODEL_RES::set_param_by_index(int i, std::string& value, int offset)
{
	USE(value);
	switch(i)
	{
		case 0: v_R=value; break; // global_model
		default: throw Exception_Too_Many(i, 1, offset); break;
	}
}
// -------------------------------------------------------------------------- //
std::map<string, PARA_BASE MODEL_RES::*> MODEL_RES::_param_dict
  = boost::assign::map_list_of
  ("R", (PARA_BASE MODEL_RES::*)  (&MODEL_RES::v_R));

std::map<string, PARA_BASE MODEL_RES::*> MODEL_RES::_param_dict_low
  = boost::assign::map_list_of
    (toLower("R"), (PARA_BASE MODEL_RES::*)
        (&MODEL_RES::v_R));
// -------------------------------------------------------------------------- //
void MODEL_RES::set_param_by_name(string Name, string Value)
{
	PARA_BASE MODEL_RES::* x = (OPT::case_insensitive)?
		(_param_dict_low[toLower(Name)]) : (_param_dict[Name]);
	trace3("MODEL_RES::set_param_by_name", Name, OPT::case_insensitive, x);
	if(x) {
		PARA_BASE* p = &(this->*x);
		*p = Value;
		return;
	}
	throw Exception_No_Match(Name);
}
// -------------------------------------------------------------------------- //
void COMMON_RES::precalc_first(const CARD_LIST* scope)
{
	COMMON_COMPONENT::precalc_first(scope);
}
// -------------------------------------------------------------------------- //
void COMMON_RES::precalc_last(const CARD_LIST* scope)
{
	COMMON_COMPONENT::precalc_last(scope);
	const COMMON_RES* c = prechecked_cast<const COMMON_RES*>(this);
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);
#if 0 // hmm wrong place
#endif
}
// -------------------------------------------------------------------------- //
void MODEL_RES::precalc_first()
{
	MODEL_CARD::precalc_first();
	const CARD_LIST* par_scope = scope(); USE(par_scope);
	assert(par_scope);
	MODEL_CARD::precalc_first();
	MODEL_RES *m = this; USE(m);	e_val(&(this->v_R), (double)100, par_scope);


	// @(initial_model) block
}
// -------------------------------------------------------------------------- //
void MODEL_RES::precalc_last()
{
	MODEL_CARD::precalc_last();
	const CARD_LIST* par_scope = scope(); USE(par_scope);
	assert(par_scope);
	MODEL_CARD::precalc_last();
	MODEL_RES *m = this; USE(m);	e_val(&(this->v_R), (double)100, par_scope);


	// @(initial_model) block
	// analog block global_model assignments
	// does not work
}
// -------------------------------------------------------------------------- //
void MODEL_RES::set_dev_type(const std::string& new_type)
{
	trace1("MODEL_RES::set_dev_type", new_type);

	_key = new_type;
	if (OPT::case_insensitive)
		notstd::to_lower(&_key);
}


// ********************************* DEV_RES ********************************* //
DEV_RES::DEV_RES()
    : ADMS_BASE(),
    _nodes(),
    _nodemap(NULL),
    _states_q1(NULL),
	_br_p_n(NULL) /* p,n */
{
	attach_common(&Default_COMMON_RES);

	_n = _nodes;
	uint_t i = 0;
	// p electrical external
	assert(!(_n[i].n_())); i++;
	// n electrical external
	assert(!(_n[i].n_())); i++;

	for (int ii=0; ii<OPT::_keep_time_steps; ++ii){
		// not here!
		_states[ii] = NULL;
	}
}
// -------------------------------------------------------------------------- //
DEV_RES::DEV_RES(const DEV_RES& p) :
    ADMS_BASE(p),
    _nodes(),
    _nodemap(NULL),
    _states_q1(NULL),
	_br_p_n(NULL) /* p,n */
{
	for (int ii=0; ii<OPT::_keep_time_steps; ++ii){
		// not here!
		_states[ii] = NULL;
	}

	_n = _nodes;
	for (uint_t ii = 0; ii < int_nodes() + max_nodes(); ++ii){
		_n[ii] = p._n[ii];
		trace1("DEV_RES::DEV_RES", ii);
	}

	for (int ii=0; ii<OPT::_keep_time_steps; ++ii){
		_states[ii] = NULL;
	}
}
// -------------------------------------------------------------------------- //
// -------------------------------------------------------------------------- //
DEV_RES::~DEV_RES()
{
}
// ---------------- all analog functions from verilog-module here: ---------- //

// -------------------------------------------------------------------------- //
std::map<string, PARA_BASE DEV_RES::*> DEV_RES::_param_dict;

std::map<string, PARA_BASE DEV_RES::*> DEV_RES::_param_dict_low;
// -------------------------------------------------------------------------- //
void DEV_RES::set_param_by_name(std::string Name, std::string value)
{
	PARA_BASE DEV_RES::* x = (OPT::case_insensitive)?
		(_param_dict_low[toLower(Name)]) : (_param_dict[Name]);
	trace3("DEV_RES::set_param_by_name", Name, OPT::case_insensitive, x);
	if(x) {
		PARA_BASE* p = &(this->*x);
		*p = value;
		return;
	}
	ADMS_BASE::set_param_by_name(Name,value);
}
// -------------------------------------------------------------------------- //
void COMMON_RES::expand(const COMPONENT* d)
{
	trace2("COMMON_RES::expand", modelname(), OPT::_keep_time_steps);

	COMMON_COMPONENT::expand(d);
	attach_model(d);
	const MODEL_RES* m = dynamic_cast<const MODEL_RES*>(model());
	if (!m) {
		throw Exception_Model_Type_Mismatch(d->long_label(), modelname(), "res");
	}
}
// -------------------------------------------------------------------------- //
void DEV_RES::expand()
{
	ADMS_BASE::expand();
	
	const COMMON_RES* c = static_cast<const COMMON_RES*>(common());
	assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m);
	trace2("DEV_RES::expand", c->modelname() ,OPT::_keep_time_steps);

	if (!subckt()) {
		new_subckt();
	}else{
	}

	init_nodemap();
	guesstopology();
	// orbit_number(_nodemap, 2);

  // allocate state vectors

	// setup internal nodes
	// p electrical external
	// n electrical external
	if (_sim->is_first_expand()) {
		precalc_first();
		precalc_last();
		trace4("DEV_RES::expand nodes", net_nodes(), max_nodes(), matrix_nodes(), int_nodes());

		for(uint_t ii = net_nodes(); ii < matrix_nodes(); ++ii) {
#ifdef HAVE_ADP_NODE
			trace2("DEV_RES::expand nodes", ii, _n[ii].is_adp());
			if(!_n[ii].is_adp()){
#endif
			if(uint_t(_nodemap->cycle(ii))<ii) { untested();
				_n[ii] = _n[_nodemap->cycle(ii)];
			}else if(_n[ii].n_()) { untested();
				// already set up...
			}else if(ii < max_nodes()){ untested();
				// omitted
				_n[ii].set_to_ground(this);
			}else{ untested();
				_n[ii].new_model_node(node_name(ii), this);
			}
#ifdef HAVE_ADP_NODE
			} else if ( !_n[ii].a_()){ itested();
				trace0("DEV_RES::expand node, registering new adpnode");
				// no external adp nodes, so no unconnected ones.
				_n[ii].new_model_adp_node(node_name(ii), this);
				assert(_n[ii].t_()!=INVALID_NODE);
			} else {
				trace1("DEV_RES::expand node,not registering new adpnode", _n[ii].a_()->long_label() );

			}
#endif
		}

		assert(max_nodes() != 0);
		for (uint_t ii = 0; ii < matrix_nodes(); ++ii)
		{
			trace1("DEV_RES::expand matrix node check", ii);
			assert(_n[ii].t_()!=INVALID_NODE);
#ifdef HAVE_ADP_NODE
			assert(_n[ii].n_() || _n[ii].is_adp());
#else
			assert(_n[ii].n_());
#endif
		}
		// current probes as in V(a) <+ I(b)

		// sources, by branch
       // p,n, 1
		if (!_br_p_n) {
			std::string type="adms_i";
			const CARD* p = device_dispatcher[type];
			if(!p){
				error(bDANGER, "cannot instanciate source of type %s. load module?", type.c_str());
			}else{
				_br_p_n = dynamic_cast<COMPONENT*>(p->clone());
				assert(_br_p_n);
				_br_p_n->set_slave();
				subckt()->push_front(_br_p_n);
			}
		}else{
		}

		// contributions, setup
  // B p,n


		{ // p,n
			unsigned c = 0;
			unsigned f = 0;
			node_t nodes[] = {
				_n[n_p], _n[n_n]
			};
			COMPONENT**brs=NULL;
			ADMS_SOURCE* B = prechecked_cast<ADMS_SOURCE*>(_br_p_n);
			assert(B);
			B->set_parameters_va(
			    "v_p_n",
			    this, NULL, 0., 2+c+f,
			    _br_p_n_xxx, _br_p_n_xxx_old,
			    2*(1+c), nodes, f, brs); // p,n
		} // p,n
		// netlist
	}else{ untested();
	}
	// sckt_size 1
	assert(subckt());
	trace0("DEV_RES::expand: expanding netlist");
	subckt()->expand();
	//	subckt()->set_slave(); NO. doesnt make sense

  delete (_nodemap);
  _nodemap=NULL;
}
// -------------------------------------------------------------------------- //
void DEV_RES::precalc_first()
{
	ADMS_BASE::precalc_first();
	const CARD_LIST* par_scope = scope(); USE(par_scope);
	assert(par_scope);
	if(subckt()) subckt()->precalc_first();
// 	<admst:for-each select="variable[input='yes']">
// 	 res.e_val(0,scope());
// 	</admst:for-each>
	  //	_br_p_n->precalc_first();
}
// -------------------------------------------------------------------------- //
void DEV_RES::precalc_last()
{
	ADMS_BASE::precalc_last();
	if(subckt()) subckt()->precalc_last();
}
// -------------------------------------------------------------------------- //
void DEV_RES::internal_precalc()
{
  trace1(" DEV_RES::internal_precalc()", long_label());

#define _STATIC
#define _DYNAMIC
#undef _STATIC
#undef _DYNAMIC

	set_converged();
}
// -------------------------------------------------------------------------- //
#define tr_call_iwants(m_1, m_2) _sim->_aa.iwant(_n[m_1].m_(), _n[m_2].m_()); _sim->_lu.iwant(_n[m_1].m_(), _n[m_2].m_())
// -------------------------------------------------------------------------- //

void DEV_RES::tr_iwant_matrix()
{
	trace0("DEV_RES::tr_iwant_matrix()");
	assert(is_device());
	if (subckt()) {
      subckt()->tr_iwant_matrix();
	}else{ unreachable();
	}
  //	ADMS_BASE::tr_iwant_matrix();
	  // p:p
	  // p:n
	  // n:p
	  // n:n
	//tr_iwant_matrix_extended();
}
// -------------------------------------------------------------------------- //
void DEV_RES::ac_iwant_matrix()
{
	trace0("DEV_RES::ac_iwant_matrix()");
	if (subckt()) {
      subckt()->ac_iwant_matrix();
	}else{ unreachable();
	}
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_begin()
{
	subckt()->tr_begin();
	const COMMON_RES* c = prechecked_cast<const COMMON_RES*>(common());
	assert(c); USE(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	assert(m);
	USE(m);
	
	trace0("DEV_RES::tr_begin");
	ADMS_BASE::tr_begin();

	// initial step

	// /initial step

	assert(0+0 == _num_states);
	for(int ii=0; ii<OPT::_keep_time_steps; ii++){
		std::fill_n(_states[ii], (_num_states)*2, 0);
	}
	std::fill_n(_states_q1, (_num_states), 0);


        //     in storag:
        // _m1 = _m0 = CPOLY1(0., 0., 0.);
	internal_precalc();

	//	tr_eval();

	q_load();
}
// -------------------------------------------------------------------------- //
void DEV_RES::dc_advance()
{
	subckt()->dc_advance();
	trace0("DEV_RES::dc_advance");

	// ELEMENT:: does nothing

	ADMS_BASE::dc_advance();

	// ??
	//		for( unsigned i=0; i<_num_states; ++i){
	//			_states_1[2*i+1]=_states[0][2*i+1];
	//		}
	//

}
// -------------------------------------------------------------------------- //
#ifdef HAVE_TT
void DEV_RES::tt_accept()
{
	subckt()->tt_accept();
}
// -------------------------------------------------------------------------- //
#if HAVE_TT + 0 == 2
void DEV_RES::do_tt()
{
	subckt()->do_tt();
}
#else
void DEV_RES::stress_apply()
{
	subckt()->stress_apply();
}
#endif
// -------------------------------------------------------------------------- //
void DEV_RES::tt_advance()
{
	subckt()->tt_advance();
	trace3("DEV_RES::tt_advance", short_label(), _sim->_time0, _sim->_dt0);
	if (_time[0] > _sim->_time0) {untested();
		for (int i=0; i<OPT::_keep_time_steps-1; ++i) {
			_time[i] = _time[i+1];
			//_y[i] = _y[i+1];
		}
		_time[OPT::_keep_time_steps-1] = 0.;
		// _y[OPT::_keep_time_steps-1] = FPOLY1(0., 0., 0.);
	}

	for (int i=OPT::_keep_time_steps-1; i>=0; --i) {
		// FIXME: copy all timesteps to 0
		_time[i] = 0.;
		//    assert(_time[i] < _time[i-1] || _time[i] == 0.);
	}
	_dt=0;
}
/*--------------------------------------------------------------------------*/
void DEV_RES::tt_begin()
{
	trace1("DEV_RES::tt_begin", _sim->_Time0);
	ADMS_BASE::tt_begin();
	subckt()->tt_begin();
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_stress_last()
{
	trace1("DEV_RES::tr_stress_last", _sim->_Time0);
	ADMS_BASE::tr_stress_last();
	subckt()->tr_stress_last();
}
#endif
// -------------------------------------------------------------------------- //
void DEV_RES::tr_restore()
{
	ADMS_BASE::tr_restore(); internal_precalc();
	subckt()->tr_restore();
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_advance()
{
	subckt()->tr_advance();
  trace3("DEV_RES::tr_advance", _sim->_time0, _time[0], _time[1]);
  ADMS_BASE::tr_advance(); // does time.

  // shift states, clear states[0]
  double* t = _states[OPT::_keep_time_steps-1];
  for (int ii = OPT::_keep_time_steps-1;  ii > 0;  --ii){
    _states[ii] = _states[ii-1];
  }
  _states[0] = t;

  //initial guess.
  notstd::copy_n(_states[1], 2*(unsigned) _num_states, _states[0]);


// storage would do:
//for (int i=OPT::_keep_time_steps-1; i>0; --i) {
//_i[i] = _i[i-1];
// }
//  element does:
//for (int i=OPT::_keep_time_steps-1; i>0; --i) {
//  assert(_time[i] < _time[i-1] || _time[i] == 0.);
//  _time[i] = _time[i-1];
//  _y[i] = _y[i-1];
//}
// _time[0] = _sim->_time0;
//
// _dt = _time[0] - _time[1];
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_regress()
{
	ADMS_BASE::tr_regress();
	assert(subckt()); subckt()->tr_regress();
}
// -------------------------------------------------------------------------- //
bool DEV_RES::tr_needs_eval()const
{
	trace3("DEV_RES::tr_needs_eval", converged(), is_q_for_eval(), _sim->is_advance_iteration());
	if (is_q_for_eval()){ untested();
		return false; // needed?
	}else if ( !OPT::lcbypass
	  || !converged()
	  || _sim->is_advance_or_first_iteration() ) { itested();
		return true;
	}
	if( subckt()->tr_needs_eval()){
		// return true; no (not slave)
	}

	if (_time[1] == 0){
		trace0("tr_needs_eval: //BUG// needed?? for ngspice jfet, but not for spice3f5 jfet");
		return true;
	}

	// check the node voltages, reference to ground
	if (!conchk( n_p, OPT::reltol*OPT::bypasstol)) {
		return true;
	}
	// relative check n p FIXME: iterate over branches?!
	if (!conchk( n_n, n_p, OPT::reltol*OPT::bypasstol)) {
		return true; // is this happening/necessary (slow)?
	}
	if (!conchk( n_n, OPT::reltol*OPT::bypasstol)) {
		return true;
	}

	trace0("DEV_RES::tr_needs_eval: no");
	return false;
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_eval_kept()
{
#if 0
#endif // 0
}
// -------------------------------------------------------------------------- //
// MODEINITFLOAT = normal iteration
// MODEINITPRED  = 1st iter at a new time point
// MODEINITTRAN  = 1st iter at 1st time pt after initial DC
// MODEINITFIX   = like FLOAT, but honor options like "off"
// MODEINITJCT   = initial guess
// MODEINITSMSIG = like FLOAT, but setup for small signal, don't load arrays
// -------------------------------------------------------------------------- //
bool DEV_RES::do_tr()
{
	trace1("DEV_RES::do_tr", long_label());

	assert(OPT::_keep_time_steps <= 8);
#ifndef USE_DTIME
	assert(_dt == NOT_VALID || ::conchk(_dt, _time[0] - _time[1]));
#endif

	// convergence check -- gnucap method
	if (_sim->analysis_is_tran_dynamic())
	{
		trace1("DEV_RES::do_tr tran dynamic", long_label());
		tr_eval(); // if needed??
	} else {
		tr_eval(); // if needed??
	}

	set_converged(subckt()->do_tr());
	if(converged()){ itested();
		set_converged(conv_check());
	}else{
	}

	bool needs_load = !converged();

	store_values();

	//  if (needs_load) q_load();
	trace2("DEV_RES::do_tr done ", converged(), needs_load );
	return converged();
}
// -------------------------------------------------------------------------- //
void DEV_RES::keep_ic()
{
#ifdef HAVE_KEEPCOEFF
	subckt()->keep_ic();
#endif

	//double x =  dn_diff(_n[OUT1].v0(),_n[OUT2].v0() );
	COMMON_RES* c = prechecked_cast< COMMON_RES*>(mutable_common());
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);

	trace1("DEV_RES::keep_ic", long_label() );
}
// -------------------------------------------------------------------------- //
void DEV_RES::store_values()
{
  trace1("DEV_RES::store_values", long_label());
  // notstd::copy_n(_states[0],(unsigned) 2*_num_states, _states_1);


  // ELEMENT does y[0] -> y_1
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_queue_eval()
{
	ADMS_BASE::tr_queue_eval();
	subckt()->tr_queue_eval();
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_load()
{
	trace5("DEV_RES::tr_load()", long_label(), _sim->is_inc_mode(),
	                   OPT::traceload, _loaditer, _sim->iteration_tag());

#if !defined(NDEBUG)
  if (_loaditer == (unsigned)_sim->iteration_tag()){
	  error(bDANGER, "ELEMENT::tr_load_source. double load\n");
    return;
  }
  _loaditer = _sim->iteration_tag();
#endif

	if( !OPT::traceload || !_sim->is_inc_mode()) {
		subckt()->tr_load();
	} else {
		// subdevices have queued themselves if necessary.
	}
	trace0("DEV_RES::tr_load");
          /// BUG: only dynamic!

  _loaditer = _sim->iteration_tag();
}
// -------------------------------------------------------------------------- //
void DEV_RES::tr_unload()
{
	untested();
	incomplete();
	_sim->mark_inc_mode_bad();
	tr_load();
}
// -------------------------------------------------------------------------- //
TIME_PAIR DEV_RES::tr_review()
{
	assert(_dt == NOT_VALID || ::conchk(_dt, _time[0] - _time[1]));

	double timestep = NEVER;

    //----- (DEVtrunc)
	//-----

#ifdef USE_DTIME
	_dt_by._error_estimate = tr_review_check_and_convert(timestep);
	_dt_by._event = NEVER;
#else
	_time_by._error_estimate = tr_review_check_and_convert(timestep);
	_time_by._event = NEVER;
#endif

	assert(subckt());
#ifdef USE_DTIME
	_dt_by.
#else
	_time_by.
#endif
	  min( subckt()->tr_review() );


#ifdef USE_DTIME
	return  _dt_by;
#else
	return  _time_by;
#endif
}
// -------------------------------------------------------------------------- //
// -------------------------------------------------------------------------- //
// -------------------------------------------------------------------------- //
void DEV_RES::tr_accept()
{
	DEV_RES* d = this; USE(d);
	subckt()->tr_accept();
	const COMMON_RES* c = prechecked_cast<const COMMON_RES*>(common());
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);

  trace0("DEV_RES::tr_accept");


  if (_sim->analysis_is_dcop() || _sim->analysis_is_ac()) {
    assert(_dt == NOT_VALID || ::conchk(_dt, _time[0] - _time[1]));
    // int mode;
    // mode = MODEINITSMSIG;
    // huh??    load(mode);
	}else{
	}

	// hmmm
	if(_sim->uic_now()){
#define NOJAC
#ifdef HAVE_KEEPCOEFF
# define _DDT( qq, stateno) (( _states[0][stateno*2] - _states[1][stateno*2] ) * OPT::keepcoeff)
#endif
#undef STATIC_RHS
#define STATIC_RHS 0
#		include "res_res_tr.hxx"
#undef STATIC_RHS
#define STATIC_RHS 1
#undef NOJAC
#undef _DDT
	}else{
// analog:evaluate
	}

} // tr_accept
// -------------------------------------------------------------------------- //
double DEV_RES::tr_probe_num(const std::string& x)const
{
	trace3("DEV_RES::tr_probe_num", _dt, _time[0], _time[1]);
	assert(_dt == NOT_VALID || ::conchk(_dt, _time[0] - _time[1]));
	const COMMON_RES* c = prechecked_cast<const COMMON_RES*>(common());
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);
	// node probes

	// verilog-variables ('global_...' eq. with 'ask' field)

#ifndef NDEBUG
	if( Umatch(x, "ddd") ) return _ddtmindt_index;
#endif

  return ADMS_BASE::tr_probe_num(x);
}
// -------------------------------------------------------------------------- //
void DEV_RES::ac_begin()
{
	ADMS_BASE::ac_begin();
	internal_precalc();
	untested();
	// tr_accept();
}
// -------------------------------------------------------------------------- //

void DEV_RES::do_ac()
{
  assert(OPT::_keep_time_steps <= 8);
  assert(_dt == NOT_VALID || ::conchk(_dt, _time[0] - _time[1]));

	  // msb p,n
	  //  _br_p_n
	// msb p,n


	  std::fill_n(_br_p_n_xxx,
		    + 2 // constant and self admittance
		    + 0 // V
			 + 0 // I val (unnecessary?)
			 + 0 // I raw
	  , 0.);
	  std::fill_n(_br_p_n_xxx_old,
		    + 2 // constant and self admittance
		    + 0 // V
			 + 0 // I val (unnecessary?)
			 + 0 // I raw
	  , 0.);

  //pzLoad(_sim->_jomega);

  ac_eval();

  #if 0
  #endif
}
// -------------------------------------------------------------------------- //
void DEV_RES::ac_load()
{
	subckt()->ac_load();
}

// -------------------------------------------------------------------------- //
void DEV_RES::init_nodemap()
{
	assert(!_nodemap);
	const unsigned nn = 2;
	_nodemap = new PARTITION<nn>();
}
// -------------------------------------------------------------------------- //
void DEV_RES::guesstopology ()
{
	const COMMON_COMPONENT* c = prechecked_cast<const COMMON_COMPONENT*>(common());
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);
	DEV_RES* d = this; USE(d);

//	#include "res_res_top.hxx"
{ /* -------------------- */	double R = std::numeric_limits<double>::quiet_NaN();
      USE(R);

} /* -------------------- */

}
// -------------------------------------------------------------------------- //
bool DEV_RES::conv_check()const
{


	return true; // use subdevices.
}

// -------------------------------------------------------------------------- //
// write G and C into matrix and matrix_old
void DEV_RES::ac_eval()
{
	DEV_RES* d = this; USE(d);
	trace0("DEV_RES::ac_eval");

	const COMMON_RES* c = prechecked_cast<const COMMON_RES*>(common());
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);

	double CKTga0 = 1.; USE(CKTga0); // BUG (necessary?)
	double ddtone = 1.; USE(ddtone); // not necessary in the end?

	{
	// fixme: remerge _tr.hxx?
	// #HACK:
		#define _DDT(qq, stateno) 0
		#include "res_res_ac.hxx"
		#undef _DDT
	}
}
// -------------------------------------------------------------------------- //
// -------------------------------------------------------------------------- //
void DEV_RES::tr_eval()
{
	DEV_RES* d = this; USE(d);
	trace2("DEV_RES::tr_eval", _sim->analysis_is_static(), _sim->_time0);

		// ?

	  std::fill_n(_br_p_n_xxx,
		    + 2 // constant and self admittance
		    + 0 // V
			 + 0 // I val (unnecessary?)
			 + 0 // I raw
	  , 0.);

	const COMMON_RES* c = prechecked_cast<const COMMON_RES*>(common());
	USE(c); assert(c);
	const MODEL_RES* m = prechecked_cast<const MODEL_RES*>(c->model());
	USE(m); assert(m);

	// states: false
	// ddts: 0
	// idts: 0
	
	{
		#include "res_res_tr.hxx"
	}

	// this is what cap does.
	set_converged(conv_check());
	trace2("tr_eval", long_label(), converged());

	  // _br_p_n->do_tr();
}

// -------------------------------------------------------------------------- //
COMMON_RES::COMMON_RES(const COMMON_RES& p) : COMMON_ADMS(p)
{
}
// -------------------------------------------------------------------------- //
COMMON_RES::COMMON_RES(int c) :
    COMMON_ADMS(c)
{
}
// -------------------------------------------------------------------------- //
COMMON_RES::~COMMON_RES()
{
}
// -------------------------------------------------------------------------- //
bool COMMON_RES::operator==(const COMMON_COMPONENT& x)const
{
	const COMMON_RES* p = dynamic_cast<const COMMON_RES*>(&x);
	return (p
	    && COMMON_COMPONENT::operator==(x));
}
// -------------------------------------------------------------------------- //
#if 0
map<string, PARA_BASE COMMON_RES::*> COMMON_RES::_param_dict
;A
#endif
// -------------------------------------------------------------------------- //
void COMMON_RES::set_param_by_name(std::string name, std::string value)
{
	USE(value);



#if 0
	PARA_BASE COMMON_RES::* x = (_param_dict[Name]);

  if(x) {
    PARA_BASE* p = &(this->*x);
    *p = Value;
		return;
	}
#endif
	throw Exception_No_Match(name);
}
// -------------------------------------------------------------------------- //
// -------------------------------------------------------------------------- //

}// namespace